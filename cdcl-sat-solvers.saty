@require: class-slydifi/theme/arctic
@require: ruby/ruby
@require: easytable/easytable
@require: bibyfi/bibyfi
@require: bibyfi/bibyfi-IEEETran
@require: azmath/azmath
@require: matrix/matrix
@require: colorbox/colorbox
@require: arrows/arrows
@require: arrows/commands
@require: fss/fss
@require: fss/fonts
@require: latexcmds/latexcmds
@require: fss/style
@require: base/list-ext

@import: Colors
@import: tikzyfi
@import: references
@import: presets
@import: theorems
@import: mymath
@import: utils

open LatexCmds
open SlydifiOverlay
open FigBox
open ArrowCommands
open MyMath
open TikZyFi
open EasyTableAlias

let math-int i = math-char MathInner (arabic i)
let-inline \ok = {${\circ}}
let-inline \ng = {${\times}}
let-inline ctx \eqref key = 
  match get-cross-reference (`eq:` ^ key ^ `:num`) with
    | Some(label) -> 
      read-inline ctx (embed-string (`(` ^ label ^ `)`))
    | None -> read-inline ctx { (??) }
let-math \eqrefm key = ${\text!{\eqref(key);}}
let-block ctx +small arg = 
  read-block (ctx |> set-font-size 15pt) arg
let-inline ctx \small arg = 
  read-inline (ctx |> set-font-size 15pt) arg
let-block ctx +very-small arg = 
  read-block (ctx |> set-font-size 12pt) arg
let-math \SAT = ${\mathrm{SAT}}
let-math \CNF = ${\mathrm{CNF}}
let-math \NP = ${\mathrm{NP}}
let sudoku ctx = 
  let dx = 36pt
   in List.concat
      [ [ stroke 2.5pt Color.black
            (Gr.line (dx *' 2., 0pt) (dx *' 2., dx *' 4.))
        ; stroke 2.5pt Color.black
            (Gr.line (0pt, dx *' 2.) (dx *' 4., dx *' 2.))
        ]
      ; List.concat 
        (Utils.generate 4 
        (fun j ->
          List.concat (Utils.generate 4 
            (fun i -> 
              
              (
                let imath = math-int (i + 1) in
                let jmath = math-int (j + 1) in
                let name = read-inline ctx {${d_{#imath#jmath}}} in
                let (w, h, d) = get-natural-metrics name in
              [ draw-text 
                  ( dx *' float i +' (dx -' w) *' 0.5 
                  , dx *' float j +' (dx -' h) *' 0.5 
                  )
                   name
              ; stroke 1pt Color.black 
                (Gr.rectangle 
                (dx *' float i , dx *' float j)
                (dx *' float (i+1) , dx *' float (j+1))
                )
              ])
            )
        )))
      ]


in 
document '<
  +set-config(slydifi-cfg);
  +make-title(|
    title = {|充足可能性ソルバ（SATソルバ）の原理|};
    author = {|Hiromi ISHII|};
    date = {|2024-03-10|Tsukuba Computer Mathematics Seminar 2024|};
  |);

  +section{|自己紹介|}<
    +frame{自己紹介}<
      +listing{
        * \ruby[`いし`; `い`; `ひろ`; `み`]{|石|井|大|海|}
        * 2018年度 筑波大学数学専攻博士後期課程修了（照井研）
        * 計算機合宿には2014年から参加
        * 現職：Haskell製大規模数値計算ベンチャー研究開発職
        * 宣伝：今年 05/11, 12 に横浜でお芝居をするので興味のある方は是非観にきてください
      }
    >
  >

  +section{|充足可能性ソルバ（SATソルバ）の原理|}<
    +frame{本日の話題：充足可能性問題とSATソルバ}<
      +listing{
        * \emph{充足可能性問題}：与えられた\emph{命題論理式}が\emph{（古典的に）充足可能}かどうかを判定する問題
          ** \emph{古典命題論理式}：\emph{命題変数}${P_1, \ldots, Q_1, \ldots,} を${\land}（かつ）、${\lor}（または）、${\to}（ならば）、${¬}（でない）で結んで得られる論理式
          ** \emph{古典的充足可能性}: 与えられた式を真とするような、命題変数への真偽値${\circ}（真）または${\times}（偽）の割り当てが存在するか？
        * 充足可能性（\emph{SAT}isfiability）を略して SAT と呼ぶ。
        * \emph{NP-完全}：総当たりで解けるような任意の問題が SAT に帰着できる
          ** 本来 ${\SAT} は判定問題だが、具体的な求解まで含めて${\SAT}と呼ぶ事が多い
        * 色々な問題が SAT （やその拡張である SMTソルバ）で解け、実用上も重要
      }
    >

    +frame{SATで解ける問題の例：論理パズル}<
      +question?:({三人の島民 \cite[`Smullyan:2008`];}){
        常に嘘だけをいう嘘吐きと、本当のことだけをいう正直者だけが住む島で、A, B, C三人の島民に出会った。彼らのいうことには：

        \listing{
          * A：「BとCはどちらも正直者だ」
          * B：「Aは嘘吐きで、Cは正直者だ」
        }

        A, B, C はそれぞれ正直者か、嘘吐きか？
      }
    >

    +frame{三人の島民：回答}<
      +listing{
        * ${A, B, C}を「Aが正直者」「Bが正直者」「Cが正直者」を表す命題変数とする
        * 情報を命題論理式に変換して${\eqrefm!(`q1-cond1`) \land \eqrefm!(`q1-cond2`)}を充足する解を求めればよい：
          
          \align(${
            | A | \Longleftrightarrow B \land C \label!(`q1-cond1`)
            | B | \Longleftrightarrow \lnot A \land C \label!(`q1-cond2`)
            |
          });
        * 真偽値表を書いてみると、\emph{全員嘘吐き}だとわかる。
      }


      +small< +centering(
        let show p = if p then {${\circ}} else {${\times}} in
        let iff p q = (p && q) || ((not p) && (not q)) in
        let mkRow a b c = 
            (let one = iff a (b && c) in
             let two = iff b (not a && c) in
              List.map show [a; b; c; one; two; one && two]
            ) in
        let mkTable as0 bs cs =
              List.append
              {| ${A} | ${B} | ${C} | ${\eqrefm!(`q1-cond1`)} | ${\eqrefm!(`q1-cond2`)}
              | ${\eqrefm!(`q1-cond1`) \land \eqrefm!(`q1-cond2`)}
              |}
              (List.concat
                (List.concat
                  (List.concat 
                    (List.map 
                      (fun a -> 
                        List.map 
                          (fun b ->
                            List.map (mkRow a b) cs
                          ) 
                          bs
                      )
                      as0
                    )
                  )
                )
              )
        in {
        \easytable[c;c;c;c;c;c](mkTable [true] [true; false] [true; false]);
        \quad;
        \easytable?:[t; b; m 1; bg-r (Color.rgb 0.4 1.0 0.6) 4 5][c;c;c;c;c;c]
          (mkTable [false] [true; false] [true; false]);
      });>
    >

    +frame{SATで解ける問題の例：数独}<
      +fig-on-right(from-graphics-given-context (150pt, 150pt) sudoku)<
        +listing{
          * 簡単な例として、 ${4 \times 4} の小さな数独の問題を SAT で解くことを考える。
          * ${i, j, k \leq 4} に対し命題変数 ${P^{=k}_{ij}} を用意する（${d_{ij} = k} というきもち）。

        }
      >
      +listing{
        * 各マスには ${1, 2, 3, 4} のいずれかの数字一つを入れる。
              
        \gather(${|
         \bigwedge_{i \leq 4} \bigwedge_{j \leq 4} \pb{
           \p{P^{=1}_{ij} \vee P^{=2}_{ij} \vee P^{=3}_{ij} \vee P^{=4}_{ij}} \land
           \bigwedge_{k \leq 4} \bigwedge_{l \neq k} \paren{P^{=k}_{ij} \Longrightarrow \lnot P^{=l}_{ij}}
           }
        |});
      }
    >

    +frame{SATで解ける問題の例：数独（続）}<
        +listing{
          * 各行、各列、各 ${2 \times 2} の小ブロックには各数字 ${1, \ldots, 4} が一つずつ入る。
            ** 「各行」は次のように書ける（「各列」も${i,j}の役割を入れ換え同様）：

              \eqn(${
              \bigwedge_{i \leq 4} \bigwedge_{k \leq 4} (P^{=k}_{i1} \vee P^{=k}_{i2} \vee P^{=k}_{i3} \vee P^{=k}_{i4})
              });
            ** \emph{演習問題}：「一意性」の条件が要らない理由を考えてみよう。
            ** \emph{演習問題}：「各ブロック」の条件を書き下してみよう。
          * あとは盤面の情報を個別に ${P_{ij}^{=k}} で与えてやれば、個別の問題を SAT で解ける！
        }
    >

    +frame{SATで解ける問題の例：命題論理の定理自動証明}<
      +thm?:({古典命題論理の完全性定理および健全性定理 (Gödel)}){
        任意の古典命題論理式 ${\phi} に対し、${\phi} がどんな真偽値の割り当てに対しても真であることと、${\phi} が証明可能であることは同値である。
      }

      +cor{
        任意の古典命題論理式 ${\phi} が証明可能である必要十分条件は、${\lnot \phi} が充足可能でないことである。
      }

      +listing{
        * ${\lnot \phi} が充足可能でない事がわかれば、${\phi} が証明できたことになる！
      }
    >

    +frame{SATで解ける問題の例：SMTソルバへ}<
      +listing{
        * SATだけでも強力だが、更に\emph{述語論理}（${\forall}とか${\exists}とかを入れたやつ）に拡張した \emph{SMT （SAT Modulo Theories）ソルバ}の研究も盛んに行われている
          ** 代表的なソルバ：Z3, CvC5, etc.
        * SMT で扱える理論の例：線型計画法、整数計画問題、同値関係、配列、etc.
          ** 数独なんかは配列の理論とかを使ったほうが綺麗
          ** \emph{工学的}にもこれらはかなり重要
          ** 定理証明系で人間が手で書きたくない補題の自動証明にも使える
        * SMT は SAT ソルバを外部の理論ソルバと協業させこれらの問題を解く
          ** \emph{SAT を如何に速く解くか}が SMT の実装にも重要
      }
    >
  >

  +section{|SATソルバの原理|}<
    +frame{SATは「難しい」}<
      +listing{
        * 論理パズルの解法で見たように、すべての命題変数の有り得る真偽値の割り当てを\emph{総当たり}して、\emph{真偽値表}をつくれば原理的には解ける
          ** これは命題変数の数を ${n} とすると \emph{${2^n} 通りの場合分けが必要}になる
          ** もっと効率的な方法はないか？
        * 実は\emph{「総当たりで解ける問題」は全て SAT に帰着できる}（${\SAT}は\emph{${\NP}-完全}である）ことが知られている
          ** ${P \neq \NP} 予想が正しければ、\emph{本質的に効率的な解法は存在しない}
        * 本質的に速くなくても\emph{実用的な問題に対し十分速い}手法が研究されている
          ** 以下ではその中でも主流な\emph{CDCL 法}の原理を簡単に紹介（参考文献\cite[`Zeljic:2019`; `鍋島:2010`; `岩沼:2010`; `Torlak:2003`];）
      }
    >

    +frame{連言標準形（CNF）}<
      +listing{
        * SAT ソルバは\emph{連言標準形} (CNF) と呼ばれる形の論理式を扱うことが多い
      }

      +defn{
        \enumerate{
          * 命題変数${P_i}およびその否定${\lnot P_i}を合わせて\emph{リテラル}と呼ぶ。以下、リテラルを表すメタ変数を${l, l_i}などと書く。
          * 0個以上のリテラルを「または」で繋いだもの ${l_1 \lor \ldots \lor l_k}を\emph{節}と呼ぶ。以下、節を表すメタ変数を${C, C_i}などと書く。
          * 0個以上の節を「かつ」で繋いだ${C_1 \land \ldots \land C_m}の形の論理式を\emph{連言標準形}（Conjunctive Normal Form\emph{CNF}）と呼ぶ。
        }
      }
    >

    +frame{任意の命題論理式はCNFで表せる}<
      +thm?:({命題論理式のCNFへの変換}){
        任意の命題論理式 ${\phi}は同値なCNF ${\phi_{\CNF}}を持つ。
      }
      +listing{
        * de Morgan 則と分配則を使って変換すればよいが、自乗のオーダーかかる
        * 充足可能性だけを考えればよいのなら、結合子ごとに追加の命題変数${n_i}を導入し、各節のサイズが高々 ${3} のCNF（\emph{${3\text!{-}\CNF}}）に変換できる
      }

      +fig-on-right(
        let diag = 
              { \tikzy?:(|
                  default with
                  default-node-style = 
                    (|default-node-style with padding=2pt|) 
                      |> circle |> distance 1.25cm
                      |> style [set-font-size 12pt]
                |)
                (
                let label ctx = ctx |> plain |> distance 3pt |> style [set-font-size 10pt]
                in 
                [ node-at?:[named `root`] (coord (0pt, 0pt)) {${\lor}}
                ; node-at?:[label] (north-of `root`) {${n_0}}
                ; node-at?:[named `l`] (south-west-of `root`) {${\lnot}}
                ; node-at?:[label] (west-of `l`) {${n_1}}
                ; node-at?:[named `ld`; distance 1cm] (south-of `l`) {${\land}}
                ; node-at?:[label] (west-of `ld`) {${n_2}}
                ; node-at?:[named `P`] (south-west-of `ld`) {${P}}
                ; node-at?:[named `Q`] (south-east-of `ld`) {${Q}}
                ; node-at?:[named `R`] (south-east-of `root`) {${R}}
                ; arrow (south-west-of `root`) (north-of `l`)
                ; arrow (south-east-of `root`) (north-of `R`)
                ; arrow (south-of `l`) (north-of `ld`)
                ; arrow (south-west-of `ld`) (north-of `P`)
                ; arrow (south-east-of `ld`) (north-of `Q`)
                ]);
              }
        in textbox-with-width 6cm diag
      )<
        +listing{
          * 論理式 ${\lnot (P \land Q) \lor (R \land S)} のCNFへの変換例：

            \small{\align?:(AZMathEquation.notag)(${
              | n_0 | \land (\lnot n_0 \lor n_1 \lor R) \land (\lnot n_1 \lor n_0) \land (\lnot R \lor n_0)
              |     | \land (\lnot n_1 \lor \lnot n_2) \land (n_1 \lor n_2)
              |     | \land (\lnot n_2 \lor P) \land (\lnot n_2 \lor Q) \land (\lnot P \lor \lnot Q \lor n_2)
              |});
            }
          
          * \emph{演習問題}：他の結合子の変換規則を考えてみよう。
        }
      >
    >
  >

  +section{|まとめ|}<
    +namedframe(`まとめ`){\select(from 2){Any Questions?}{まとめ}}<
      +listing{
        * Matome here
      }
    >
    +frame-nofooter{参考文献}<
      +font-style[font-size 15pt]<
        +makebibliography 
          ?:(|sort-references=true; 
              citestyle=CiteAsNumber;
              name-shrink=true;
            |)
          (bibyfi-theme)(bibs);
      >
    >
  >
>