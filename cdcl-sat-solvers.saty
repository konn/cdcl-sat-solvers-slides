@require: class-slydifi/theme/arctic
@require: ruby/ruby
@require: easytable/easytable
@require: bibyfi/bibyfi
@require: bibyfi/bibyfi-IEEETran
@require: azmath/azmath
@require: matrix/matrix
@require: colorbox/colorbox
@require: arrows/arrows
@require: arrows/commands
@require: fss/fss
@require: fss/fonts
@require: latexcmds/latexcmds
@require: fss/style
@require: base/list-ext
@require: enumitem/enumitem

@import: Colors
@import: tikzyfi
@import: references
@import: presets
@import: theorems
@import: mymath
@import: utils
@import: diagrams
@import: dpll-machine

open LatexCmds
open SlydifiOverlay
open FigBox
open ArrowCommands
open MyMath
open EasyTableAlias
open TikZyFi

let math-int i = math-char MathInner (arabic i)
let-math \dec lit = ${#lit^\mathrm{d}}
let-math \Dec lit = ${\mathop{\mathrm{Decide}} #lit}
let-math \UP lit = ${\mathop{\mathrm{UnitProp}} #lit}
let-math \Bt lit = ${\mathop{\mathrm{Backtrack}} #lit}
let-math \Bj lit = ${\mathop{\mathrm{Backjump}} #lit}
let-math \true args = math-color Colors.green args
let-math \conflict args = math-color Colors.red args
let-math \false args = math-color (Colors.gray 0.6) args
let-math \leads-to = math-char MathRel `⤳`
let-math \rewrites-to reason = 
  let backsp r = text-in-math MathOrd 
        (fun ctx -> inline-skip (get-font-size ctx *' (0. -. r)))
  in let back1 = backsp 0.2
  in let back2 = backsp 0.5
  in ${-#back1\p{#reason}#back2\longrightarrow}
let-inline ctx \eqref key = 
  match get-cross-reference (`eq:` ^ key ^ `:num`) with
    | Some(label) -> 
      read-inline ctx (embed-string (`(` ^ label ^ `)`))
    | None -> read-inline ctx { (??) }
let-math \eqrefm key = ${\text!{\eqref(key);}}
let-block ctx +small arg = 
  read-block (ctx |> set-font-size 18pt) arg
let-inline ctx \small arg = 
  read-inline (ctx |> set-font-size 18pt) arg
let-block ctx +x-small arg = 
  read-block (ctx |> set-font-size 15pt) arg
let-inline ctx \x-small arg = 
  read-inline (ctx |> set-font-size 15pt) arg
let-block ctx +xx-small arg = 
  read-block (ctx |> set-font-size 12pt) arg
let-math \SAT = ${\mathrm{SAT}}
let-math \CNF = ${\mathrm{CNF}}
let-math \NP = ${\mathrm{NP}}
let sudoku ctx = 
  let dx = 36pt
   in List.concat
      [ [ stroke 2.5pt Color.black
            (Gr.line (dx *' 2., 0pt) (dx *' 2., dx *' 4.))
        ; stroke 2.5pt Color.black
            (Gr.line (0pt, dx *' 2.) (dx *' 4., dx *' 2.))
        ]
      ; List.concat 
        (Utils.generate 4 
        (fun j ->
          List.concat (Utils.generate 4 
            (fun i -> 
              
              (
                let imath = math-int (i + 1) in
                let jmath = math-int (j + 1) in
                let name = read-inline ctx {${d_{#imath#jmath}}} in
                let (w, h, d) = get-natural-metrics name in
              [ draw-text 
                  ( dx *' float i +' (dx -' w) *' 0.5 
                  , dx *' float j +' (dx -' h) *' 0.5 
                  )
                   name
              ; stroke 1pt Color.black 
                (Gr.rectangle 
                (dx *' float i , dx *' float j)
                (dx *' float (i+1) , dx *' float (j+1))
                )
              ])
            )
        )))
      ]


in 
document '<
  +set-config(slydifi-cfg);
  +make-title(|
    title = {|充足可能性ソルバ（SATソルバ）の原理|};
    author = {|Hiromi ISHII|};
    date = {|2024-03-10|Tsukuba Computer Mathematics Seminar 2024|};
  |);

  +section{|自己紹介|}<
    +frame{自己紹介}<
      +listing{
        * \ruby[`いし`; `い`; `ひろ`; `み`]{|石|井|大|海|}
        * 2018年度 筑波大学数学専攻博士後期課程修了（照井研）
        * 計算機合宿には2014年から参加
        * 現職：Haskell製大規模数値計算ベンチャー研究開発職
        * 宣伝：今年 05/11, 12 に横浜でお芝居をするので興味のある方は是非観にきてください
      }
    >
  >

  +section{|充足可能性ソルバ（SATソルバ）の原理|}<
    +frame{本日の話題：充足可能性問題とSATソルバ}<
      +listing{
        * \emph{充足可能性問題}：与えられた\emph{命題論理式}が\emph{（古典的に）充足可能}かどうかを判定する問題
          ** \emph{古典命題論理式}：\emph{命題変数}${P_1, \ldots, Q_1, \ldots,} を${\land}（かつ）、${\lor}（または）、${\to}（ならば）、${¬}（でない）で結んで得られる論理式
          ** \emph{古典的充足可能性}: 与えられた式を真とするような、命題変数への真偽値${\circ}（真）または${\times}（偽）の割り当てが存在するか？
        * 充足可能性（\emph{SAT}isfiability）を略して SAT と呼ぶ。
        * \emph{NP-完全}：総当たりで解けるような任意の問題が SAT に帰着できる
          ** 本来 ${\SAT} は判定問題だが、具体的な求解まで含めて${\SAT}と呼ぶ事が多い
        * 色々な問題が SAT （やその拡張である SMTソルバ）で解け、実用上も重要
      }
    >

    +frame{SATで解ける問題の例：論理パズル}<
      +question?:({三人の島民 \cite[`Smullyan:2008`];}){
        常に嘘だけをいう嘘吐きと、本当のことだけをいう正直者だけが住む島で、A, B, C三人の島民に出会った。彼らのいうことには：

        \listing{
          * A：「BとCはどちらも正直者だ」
          * B：「Aは嘘吐きで、Cは正直者だ」
        }

        A, B, C はそれぞれ正直者か、嘘吐きか？
      }
    >

    +frame{三人の島民：回答}<
      +listing{
        * ${A, B, C}を「Aが正直者」「Bが正直者」「Cが正直者」を表す命題変数とする
        * 情報を命題論理式に変換して${\eqrefm!(`q1-cond1`) \land \eqrefm!(`q1-cond2`)}を充足する解を求めればよい：
          
          \align(${
            | A | \longleftrightarrow B \land C \label!(`q1-cond1`)
            | B | \longleftrightarrow \lnot A \land C \label!(`q1-cond2`)
            |
          });
        * 真理表を書いてみると、\emph{全員嘘吐き}だとわかる。
      }


      +x-small< +centering(
        let show p = if p then {${\circ}} else {${\times}} in
        let iff p q = (p && q) || ((not p) && (not q)) in
        let mkRow a b c = 
            (let one = iff a (b && c) in
             let two = iff b (not a && c) in
              List.map show [a; b; c; one; two; one && two]
            ) in
        let mkTable as0 bs cs =
              List.append
              {| ${A} | ${B} | ${C} | ${\eqrefm!(`q1-cond1`)} | ${\eqrefm!(`q1-cond2`)}
              | ${\eqrefm!(`q1-cond1`) \land \eqrefm!(`q1-cond2`)}
              |}
              (Utils.concat-map 
                (fun a -> 
                  Utils.concat-map 
                    (fun b -> Utils.concat-map (mkRow a b) cs) 
                    bs
                )
                as0
              )
        in {
        \easytable[c;c;c;c;c;c](mkTable [true] [true; false] [true; false]);
        \quad;
        \easytable?:[t; b; m 1; bg-r (Color.rgb 0.4 1.0 0.6) 4 5][c;c;c;c;c;c]
          (mkTable [false] [true; false] [true; false]);
      });>
    >

    +frame{SATで解ける問題の例：数独}<
      +fig-on-right(from-graphics-given-context (150pt, 150pt) sudoku)<
        +listing{
          * 簡単な例として、 ${4 \times 4} の小さな数独の問題を SAT で解くことを考える。
          * ${i, j, k \leq 4} に対し命題変数 ${P^{=k}_{ij}} を用意する（${d_{ij} = k} というきもち）。

        }
      >
      +listing{
        * 各マスには ${1, 2, 3, 4} のいずれかの数字一つを入れる。
              
        \gather(${|
         \bigwedge_{i \leq 4} \bigwedge_{j \leq 4} \pb{
           \p{P^{=1}_{ij} \vee P^{=2}_{ij} \vee P^{=3}_{ij} \vee P^{=4}_{ij}} \land
           \bigwedge_{k \leq 4} \bigwedge_{l \neq k} \paren{P^{=k}_{ij} \longrightarrow \lnot P^{=l}_{ij}}
           }
        |});
      }
    >

    +frame{SATで解ける問題の例：数独（続）}<
        +listing{
          * 各行、各列、各 ${2 \times 2} の小ブロックには各数字 ${1, \ldots, 4} が一つずつ入る。
            ** 「各行」は次のように書ける（「各列」も${i,j}の役割を入れ換え同様）：

              \eqn(${
              \bigwedge_{i \leq 4} \bigwedge_{k \leq 4} (P^{=k}_{i1} \vee P^{=k}_{i2} \vee P^{=k}_{i3} \vee P^{=k}_{i4})
              });
            ** \emph{演習問題}：「一意性」の条件が要らない理由を考えてみよう。
            ** \emph{演習問題}：「各ブロック」の条件を書き下してみよう。
          * あとは盤面の情報を個別に ${P_{ij}^{=k}} で与えてやれば、個別の問題を SAT で解ける！
        }
    >

    +frame{SATで解ける問題の例：命題論理の定理自動証明}<
      +thm?:({古典命題論理の完全性定理および健全性定理 (Gödel)}){
        任意の古典命題論理式 ${\phi} に対し、${\phi} がどんな真偽値の割り当てに対しても真であることと、${\phi} が証明可能であることは同値である。
      }

      +cor{
        任意の古典命題論理式 ${\phi} が証明可能である必要十分条件は、${\lnot \phi} が充足可能でないことである。
      }

      +listing{
        * ${\lnot \phi} が充足可能でない事がわかれば、${\phi} が証明できたことになる！
      }
    >

    +frame{SATで解ける問題の例：SMTソルバへ}<
      +listing{
        * SATだけでも強力だが、更に\emph{述語論理}（${\forall}とか${\exists}とかを入れたやつ）に拡張した \emph{SMT （SAT Modulo Theories）ソルバ}の研究も盛んに行われている
          ** 代表的なソルバ：Z3, CvC5, etc.
        * SMT で扱える理論の例：線型計画法、整数計画問題、同値関係、配列、etc.
          ** 数独なんかは配列の理論とかを使ったほうが綺麗
          ** \emph{工学的}にもこれらはかなり重要
          ** 定理証明系で人間が手で書きたくない補題の自動証明にも使える
        * SMT は SAT ソルバを外部の理論ソルバと協業させこれらの問題を解く
          ** \emph{SAT を如何に速く解くか}が SMT の実装にも重要
      }
    >
  >

  +section{|SATソルバの原理|}<
    +frame{SATは「難しい」}<
      +listing{
        * 論理パズルの解法で見たように、すべての命題変数の有り得る真偽値の割り当てを\emph{総当たり}して、\emph{真理表}をつくれば原理的には解ける
          ** これは命題変数の数を ${n} とすると \emph{${2^n} 通りの場合分けが必要}になる
          ** もっと効率的な方法はないか？
        * 実は\emph{「総当たりで解ける問題」は全て SAT に帰着できる}（${\SAT}は\emph{${\NP}-完全}である）ことが知られている
          ** ${P \neq \NP} 予想が正しければ、\emph{本質的に効率的な解法は存在しない}
        * 本質的に速くなくても\emph{実用的な問題に対し十分速い}手法が研究されている
          ** 以下ではその中でも主流な\emph{CDCL 法}の原理を簡単に紹介（参考文献\cite[`Zeljic:2019`; `鍋島:2010`; `岩沼:2010`; `Torlak:2003`];）
      }
    >

    +frame{連言標準形（CNF）}<
      +listing{
        * SAT ソルバは\emph{連言標準形} (CNF) と呼ばれる形の論理式を扱うことが多い
      }

      +defn{
        \enumerate{
          * 命題変数${P_i}およびその否定${\lnot P_i}を合わせて\emph{リテラル}と呼ぶ。以下、リテラルを表すメタ変数を${l, l_i}などと書く。
          * 0個以上のリテラルを「または」で繋いだもの ${l_1 \lor \ldots \lor l_k}を\emph{節}と呼ぶ。以下、節を表すメタ変数を${C, C_i}などと書く。
          * 0個以上の節を「かつ」で繋いだ${C_1 \land \ldots \land C_m}の形の論理式を\emph{連言標準形}（Conjunctive Normal Form, \emph{CNF}）と呼ぶ。
        }

        \emph{注意}：空の節は\emph{矛盾}に、空のCNFは\emph{恒真}に対応する。
      }
    >

    +frame{任意の命題論理式はCNFで表せる}<
      +thm?:({命題論理式のCNFへの変換}){
        任意の命題論理式 ${\phi}は同値なCNF ${\phi_{\CNF}}を持つ。
      }
      +listing{
        * de Morgan 則と分配則を使って変換すればよいが、自乗のオーダーかかる
        * 充足可能性だけを考えればよいのなら、結合子ごとに追加の命題変数${n_i}を導入し、各節のサイズが高々 ${3} のCNF（\emph{${3\text!{-}\CNF}}）に変換できる
      }

      +fig-on-right(
        let diag = 
              { \tikzy?:(|
                  default with
                  default-node-style = 
                    (|default-node-style with padding=2pt|) 
                      |> circle |> distance 1.25cm
                      |> style [set-font-size 12pt]
                |)
                (
                let label ctx = ctx |> plain |> distance 3pt |> style [set-font-size 10pt]
                in 
                [ node-at?:[named `root`] (coord (0pt, 0pt)) {${\lor}}
                ; node-at?:[label] (north-of `root`) {${n_0}}
                ; node-at?:[named `l`] (south-west-of `root`) {${\lnot}}
                ; node-at?:[label] (west-of `l`) {${n_1}}
                ; node-at?:[named `ld`; distance 1cm] (south-of `l`) {${\land}}
                ; node-at?:[label] (west-of `ld`) {${n_2}}
                ; node-at?:[named `P`] (south-west-of `ld`) {${P}}
                ; node-at?:[named `Q`] (south-east-of `ld`) {${Q}}
                ; node-at?:[named `R`] (south-east-of `root`) {${R}}
                ; arrow (south-west-of `root`) (north-of `l`)
                ; arrow (south-east-of `root`) (north-of `R`)
                ; arrow (south-of `l`) (north-of `ld`)
                ; arrow (south-west-of `ld`) (north-of `P`)
                ; arrow (south-east-of `ld`) (north-of `Q`)
                ]);
              }
        in textbox-with-width 6cm diag
      )<
        +listing{
          * 論理式 ${\lnot (P \land Q) \lor (R \land S)} のCNFへの変換例：

            \x-small{\align?:(AZMathEquation.notag)(${
              | n_0 | \land (\lnot n_0 \lor n_1 \lor R) \land (\lnot n_1 \lor n_0) \land (\lnot R \lor n_0)
              |     | \land (\lnot n_1 \lor \lnot n_2) \land (n_1 \lor n_2)
              |     | \land (\lnot n_2 \lor P) \land (\lnot n_2 \lor Q) \land (\lnot P \lor \lnot Q \lor n_2)
              |});
            }
          
          * \emph{演習問題}：他の結合子の変換規則を考えてみよう。
        }
      >
    >

    +frame-nofooter{DPLL: CDCL の祖先}<
      +listing{
        * CDCL はDavis–Putnam–Logemann–Loveland (\emph{DPLL}) を基礎としている
        * 基本的な考え方：CNFの節やリテラルを\emph{削れるまで削ってから}場合分け
          ** 充足された節は削除できる→節が一つもなくなれば充足可能！
          ** 偽なリテラルがあれば、節から削除できる→空な節ができたら充足不能！
        * 以下の規則に従ってCNFを変形する：
          \enumerate{
            * \emph{単位節伝播}：リテラル一つだけの節${\pb{l}}があれば${l\equiv\top}とし${\lnot l}を削除
            * \emph{純リテラル}：肯定または否定のみ出現するリテラル${l}があれば${l\equiv\top}としそのリテラルを含む節を削除（コスト面から\emph{実装しない}事が多い）
            * \emph{Decide}：他規則が適用できないならリテラルを一つ選び\emph{場合分け}
              \listing{
                * 真偽を仮決めし継続。失敗したら巻き戻し (\emph{Backtrack}) 否定で確定し継続
              }
          }
      }
    >

    +frame({DPLL の動作例})(
      open DPLL in 
      let cnf = [[neg 1; pos 2]; [pos 3; pos 4]; [neg 5; neg 6]; [neg 2; neg 5; pos 6]] in
    '< 
      +listing{
        * ${\pretty-cnf!(cnf)} を DPLL で解いてみよう（\cite[`Zeljic:2019`];の例）。
        * 今後は CNF しか出て来ないので、${\cnf!(cnf)}と略記する
      }
      +small<
        +derive
          [[neg 1; pos 2]; [pos 3; pos 4]; [neg 5; neg 6]; [neg 2; neg 5; pos 6]]
          [ ( dec 1
            , [ [ff (-1); pos 2]; [pos 3; pos 4]
              ; [neg 5; neg 6]; [neg 2; neg 5; pos 6]
              ]
            , [dd 1]
            )
          ; ( unit-prop 2
            , [ [ff (-1); tt 2]; [pos 3; pos 4]
              ; [neg 5; neg 6]; [neg 2; neg 5; pos 6]
              ]
            , [dd 1; lit 2]
            )
          ; ( dec 3
            , [ [ff (-1); tt 2]; [tt 3; pos 4]
              ; [neg 5; neg 6]; [ff (-2); neg 5; pos 6]
              ]
            , [dd 1; lit 2; dd 3]
            )
          ; ( dec 5
            , [ [ff (-1); tt 2]; [tt 3; pos 4]
              ; [ff (-5); neg 6]; [ff (-2); ff (-5); pos 6]
              ]
            , [dd 1; lit 2; dd 3; dd 5]
            )
          ; ( unit-prop 6
            , [ [ff (-1); tt 2]; [tt 3; pos 4]
              ; [ff (-5); xx (-6)]; [ff (-2); ff (-5); tt 6]
              ]
            , [dd 1; lit 2; dd 3; dd 5; xx 6]
            )
          ; ( bt
            , [ [ff (-1); tt 2]; [tt 3; pos 4]
              ; [tt (-5); neg 6]; [ff (-2); tt (-5); pos 6]
              ]
            , [dd 1; lit 2; dd 3; lit (-5)]
            )
          ];
      >
    >);


    +frame-nofooter({Backtrack しまくる DPLL の動作例})(open DPLL in '< 
      +x-small<
        +derive
          [ [lit (-1); lit (-2); lit (-3); lit (-4); lit 5]
          ; [lit (-3); lit (-4); lit (-6)]
          ; [lit (-5); lit 6; lit (-1); lit 7]
          ; [lit (-7); lit 8]
          ; [lit (-2); lit (-7); lit 9]
          ; [lit (-8); lit (-9); lit 10]
          ; [lit (-10); lit 11]
          ; [lit (-11); lit 12]
          ; [lit (-10); lit (-2); lit (-12)]
          ]
          [ (rule ${\Decide[1\text!{-}4]}
            , [ [ff (-1); ff (-2); ff (-3); ff (-4); lit 5]
              ; [ff (-3); ff (-4); lit (-6)]
              ; [lit (-5); lit 6; ff (-1); lit 7]
              ; [lit (-7); lit 8]
              ; [ff (-2); lit (-7); lit 9]
              ; [lit (-8); lit (-9); lit 10]
              ; [lit (-10); lit 11]
              ; [lit (-11); lit 12]
              ; [lit (-10); ff (-2); lit (-12)]
              ]
            , [somit; dd 4]
            )
          ; (rule ${\UnitProp[5\text!{-}11]}
            , [ [ff (-1); ff (-2); ff (-3); ff (-4); tt 5]
              ; [ff (-3); ff (-4); tt (-6)]
              ; [ff (-5); ff 6; ff (-1); tt 7]
              ; [ff (-7); tt 8]
              ; [ff (-2); ff (-7); tt 9]
              ; [ff (-8); ff (-9); tt 10]
              ; [ff (-10); tt 11]
              ; [ff (-11); lit 12]
              ; [ff (-10); ff (-2); lit (-12)]
              ]
            , [somit; dd 4; somit; lit 11]
            )
          ; ( unit-prop 12
            , [ [ff (-1); ff (-2); ff (-3); ff (-4); tt 5]
              ; [ff (-3); ff (-4); tt (-6)]
              ; [ff (-5); ff 6; ff (-1); tt 7]
              ; [ff (-7); tt 8]
              ; [ff (-2); ff (-7); tt 9]
              ; [ff (-8); ff (-9); tt 10]
              ; [ff (-10); tt 11]
              ; [ff (-11); xx 12]
              ; [ff (-10); ff (-2); xx (-12)]
              ]
            , [somit; dd 4; somit; lit 11; xx 12]
            )
          ; (bt
            , [ [ff (-1); ff (-2); ff (-3); tt (-4); lit 5]
              ; [ff (-3); tt (-4); lit (-6)]
              ; [lit (-5); lit 6; ff (-1); lit 7]
              ; [lit (-7); lit 8]
              ; [ff (-2); lit (-7); lit 9]
              ; [lit (-8); lit (-9); lit 10]
              ; [lit (-10); lit 11]
              ; [lit (-11); lit 12]
              ; [lit (-10); ff (-2); lit (-12)]
              ]
            , [somit; lit (-4)]
            )
          ; (rule ${\Decide[5\text!{-}7]}
            , [ [ff (-1); ff (-2); ff (-3); tt (-4); tt 5]
              ; [ff (-3); tt (-4); ff (-6)]
              ; [ff (-5); tt 6; ff (-1); tt 7]
              ; [ff (-7); lit 8]
              ; [ff (-2); ff (-7); lit 9]
              ; [lit (-8); lit (-9); lit 10]
              ; [lit (-10); lit 11]
              ; [lit (-11); lit 12]
              ; [lit (-10); ff (-2); lit (-12)]
              ]
            , [somit; lit (-4); somit; dd 7]
            )
          ; (rule ${\UnitProp[8\text!{-}11]}
            , [ [ff (-1); ff (-2); ff (-3); tt (-4); tt 5]
              ; [ff (-3); tt (-4); ff (-6)]
              ; [ff (-5); tt 6; ff (-1); tt 7]
              ; [ff (-7); tt 8]
              ; [ff (-2); ff (-7); tt 9]
              ; [ff (-8); ff (-9); tt 10]
              ; [ff (-10); tt 11]
              ; [ff (-11); xx 12]
              ; [ff (-10); ff (-2); xx (-12)]
              ]
            , [somit; lit (-4); somit; lit 11]
            )
          ; ( bt
            , [ [ff (-1); ff (-2); ff (-3); tt (-4); tt 5]
              ; [ff (-3); tt (-4); ff (-6)]
              ; [ff (-5); tt 6; ff (-1); ff 7]
              ; [tt (-7); lit 8]
              ; [ff (-2); tt (-7); lit 9]
              ; [lit (-8); lit (-9); lit 10]
              ; [lit (-10); lit 11]
              ; [lit (-11); lit 12]
              ; [lit (-10); ff (-2); lit (-12)]
              ]
            , [somit; lit (-4); somit; lit (-7)]
            )
          ; ( rule ${\cdots}
            , [ [ff (-1); ff (-2); ff (-3); tt (-4); tt 5]
              ; [ff (-3); tt (-4); ff (-6)]
              ; [ff (-5); tt 6; ff (-1); ff 7]
              ; [tt (-7); tt 8]
              ; [ff (-2); tt (-7); tt 9]
              ; [ff (-8); ff (-9); tt 10]
              ; [ff (-10); tt 11]
              ; [ff (-11); xx 12]
              ; [ff (-10); ff (-2); xx (-12)]
              ]
            , [somit; lit (-4); somit; lit 11]
            )
          ; ( bt
            , [ [ff (-1); ff (-2); ff (-3); tt (-4); tt 5]
              ; [ff (-3); tt (-4); tt (-6)]
              ; [ff (-5); ff 6; ff (-1); lit 7]
              ; [lit (-7); lit 8]
              ; [ff (-2); lit (-7); lit 9]
              ; [lit (-8); lit (-9); lit 10]
              ; [lit (-10); lit 11]
              ; [lit (-11); lit 12]
              ; [lit (-10); ff (-2); lit (-12)]
              ]
            , [somit; lit (-4); somit; lit (-6)]
            )
          ; ( rule ${\cdots}
            , [ [ff (-1); ff (-2); ff (-3); tt (-4); tt 5]
              ; [ff (-3); tt (-4); tt (-6)]
              ; [ff (-5); ff 6; ff (-1); tt 7]
              ; [ff (-7); tt 8]
              ; [ff (-2); ff (-7); tt 9]
              ; [ff (-8); ff (-9); tt 10]
              ; [ff (-10); tt 11]
              ; [ff (-11); xx 12]
              ; [ff (-10); ff (-2); xx (-12)]
              ]
            , [somit; lit (-4); somit; lit 11]
            )
          ; ( bt
            , [ [ff (-1); ff (-2); ff (-3); tt (-4); ff 5]
              ; [ff (-3); tt (-4); lit (-6)]
              ; [tt (-5); lit 6; ff (-1); lit 7]
              ; [lit (-7); lit 8]
              ; [ff (-2); lit (-7); lit 9]
              ; [lit (-8); lit (-9); lit 10]
              ; [lit (-10); lit 11]
              ; [lit (-11); lit 12]
              ; [lit (-10); ff (-2); lit (-12)]
              ]
            , [somit; lit (-4); somit; lit (-5)]
            )
          ; ( rule ${\mathrm{Bt} \mathrel{\text!{ on }} 7,8,10,11}
            , [ [ff (-1); ff (-2); ff (-3); tt (-4); ff 5]
              ; [ff (-3); tt (-4); lit (-6)]
              ; [tt (-5); lit 6; ff (-1); lit 7]
              ; [tt (-7); lit 8]
              ; [ff (-2); tt (-7); lit 9]
              ; [tt (-8); lit (-9); ff 10]
              ; [tt (-10); lit 11]
              ; [lit (-11); lit 12]
              ; [tt (-10); ff (-2); lit (-12)]
              ]
            , [somit; lit (-5); lit (-7); lit (-8); lit (-10); lit (-11)]
            )
          ];
      >
    >);

    +frame{CDCL: Conflict-Driven Clause Learning}<
      +listing{
        * 単純総当たりよりDPLLは賢いが、Backtrack で得られる情報が少ない
          ** 折角 Backtrack でいったん真偽値が確定しても、更に Backtrack すればその情報は消えてしまう
        * Backtrack は一段階ずつしか戻らない
          ** \emph{場合分けが入れ子}になっている場合、実は直近の場合分けより\emph{もっと早くに}矛盾が起きていても延々と\emph{一段階ずつ} Backtrack してしまう
        * 矛盾からに過程を辿っていって矛盾の原因となった「理由」を見付け。\emph{学習節}としてCNFに追加してそこまで\emph{一気に巻き戻そう} (\emph{Backjump})！
          ** これが\emph{矛盾からの節学習}(Conflict-Driven Clause Learning, \emph{CDCL})
      }
    >

    +frame{CDCL: どういう学習節が望ましいか？}<
      +listing{
        * 学習節が\emph{元々の入力の帰結}であること
          ** 任意のタイミングで Backjump が起き得る
          ** いつでも使えるように、仮定が本質的には増えていてはならない
        * 「\emph{すぐに使える}」学習節であること
          ** Backjump した直後に、\emph{新しい情報}が得られないと意味がない
          ** 特に、\emph{巻き戻した段階で単位節になっている}ようにしたい
        * なるべく\emph{小さい}ほうがよい
          ** 単位節や矛盾が比較的すぐ出るようにしたい
        * \emph{含意グラフ}を考えるとこれらを満たす学習節を得られる
      }
    >

    +frame{CDCL：\emph{含意グラフ}}<
      +listing{
        * これまでに\emph{真偽を割り当てたリテラルを頂点}として持つ有向グラフ
        * 単位伝播で真になったリテラルへ、\emph{根拠となったリテラルから辺}を伸ばす
          ** 単位伝播＝「他のリテラルが真にならなかったので最後の一つを真にする」
          ** 「根拠」：つまり、\emph{真偽を確定させた節}に含まれる\emph{他のリテラルの否定}
          ** ただ一つのリテラルを持つ単位節のリテラルや、場合分けリテラルの場合入次数はゼロ
        * 以下は最初の ${\cnf!(open DPLL in [[neg 1; pos 2]; [pos 3; pos 4]; [neg 5; neg 6]; [neg 2; neg 5; pos 6]])} に対する含意グラフの例
      }
      +fig-on-right(
          let prev ctx = ctx 
                |> fc Colors.black 
                |> style [set-text-color Colors.white]
          in let contra ctx = ctx 
                |> fc Colors.red 
                |> style [set-text-color Colors.white]
          in  let cfg = (|default with 
                      default-node-style = default-node-style |> circle |> padding 5pt;
                      unit-length = 1.25cm;
                    |) 
          in textbox-with-width 5cm {\x-small{
                \tikzy?:(cfg)[
                  matrix
                    [ [node?:[prev] {${3}}; node?:[named`5`] {${5}}; node?:[contra; named`6`] {${6}}; ]
                    ; [node?:[named `1`; prev] {${1}}; node?:[named `2`] {${2}}; node?:[named `-6`; contra] {${\widebar{6}}}]
                    ]
                ; arrow (east-of `5`) (west-of `6`)
                ; arrow (east-of `1`) (west-of `2`)
                ; arrow (north-east-of `2`) (south-west-of `6`)
                ; arrow (east-of `2`) (west-of `-6`)
                ];
          }}
      )<
        +listing{
          * 黒丸はこれよりも前の場合分けで仮置きされたリテラル
          * 赤丸は互いに矛盾したリテラル
        }
      >
    >

    +frame{CDCL：含意グラフと学習節1 - カットと矛盾原因}<
      +listing{
        * 含意グラフを以下の二つの集合に\emph{カット}すると、矛盾への\emph{原因}が得られる
          \enumerate{
            * \emph{conflict side}: 直接矛盾した頂点をどちらも含む
            * \emph{reason side}: 現在の場合分けの起点と以前の場合分け対象全部を含む
          }
        * このとき、\emph{reason side}のリテラルはconflict side の\emph{原因}になっている
          ** 特に\emph{conflict sideに向かう辺を持つreason sideの頂点}があれば十分
      }
    >

    +frame{\small{例：Backtrackしまくる例の最初の矛盾までの含意グラフ}}<
      +small< +eqn?:(AZMathEquation.notag)(${
        \cnf!(open DPLL in 
          [ [ff (-1); ff (-2); ff (-3); ff (-4); tt 5]
          ; [ff (-3); ff (-4); tt (-6)]
          ; [ff (-5); ff 6; ff (-1); tt 7]
          ; [ff (-7); tt 8]
          ; [ff (-2); ff (-7); tt 9]
          ; [ff (-8); ff (-9); tt 10]
          ; [ff (-10); tt 11]
          ; [ff (-11); xx 12]
          ; [ff (-10); ff (-2); xx (-12)]
          ]
        )
      });>
      +x-small< +centering{
        \tikzy?:(large-graph-cfg)(
          List.append
          large-graph-nodes
          [ lines?:[pc (Colors.gray 0.7); lw 2pt]
              [ between (north-of `2`) 
                (proj (north-of `2`) (north-of `11`, south-of `11`))
              ; between (center-of `10`) (center-of `-12`)
              ; between (south-of `9`) (south-of `11`)
              ]
          ]
        );
      }>
    >

    +frame-nofooter({同じ例の CDCL の動作})(open DPLL in '< 
      +xx-small<
        +derive
          [ [lit (-1); lit (-2); lit (-3); lit (-4); lit 5]
          ; [lit (-3); lit (-4); lit (-6)]
          ; [lit (-5); lit 6; lit (-1); lit 7]
          ; [lit (-7); lit 8]
          ; [lit (-2); lit (-7); lit 9]
          ; [lit (-8); lit (-9); lit 10]
          ; [lit (-10); lit 11]
          ; [lit (-11); lit 12]
          ; [lit (-10); lit (-2); lit (-12)]
          ]
          [ ( rule ${\cdots}
            , [ [ff (-1); ff (-2); ff (-3); ff (-4); tt 5]
              ; [ff (-3); ff (-4); tt (-6)]
              ; [ff (-5); ff 6; ff (-1); tt 7]
              ; [ff (-7); tt 8]
              ; [ff (-2); ff (-7); tt 9]
              ; [ff (-8); ff (-9); tt 10]
              ; [ff (-10); tt 11]
              ; [ff (-11); xx 12]
              ; [ff (-10); ff (-2); xx (-12)]
              ]
            , [somit; dd 4; somit; lit 11; xx 12]
            )
          ; (bj
            , [ [ff (-1); ff (-2); lit (-3); lit (-4); lit 5]
              ; [lit (-3); lit (-4); lit (-6)]
              ; [lit (-5); lit 6; ff (-1); lit 7]
              ; [lit (-7); lit 8]
              ; [ff (-2); lit (-7); lit 9]
              ; [lit (-8); lit (-9); lit 10]
              ; [lit (-10); lit 11]
              ; [lit (-11); lit 12]
              ; [lit (-10); ff (-2); lit (-12)]
              ; [lit (-10); ff (-2)]
              ]
            , [dd 1; dd 2]
            )
          ; (unit-prop (-10)
            , [ [ff (-1); ff (-2); lit (-3); lit (-4); lit 5]
              ; [lit (-3); lit (-4); lit (-6)]
              ; [lit (-5); lit 6; ff (-1); lit 7]
              ; [lit (-7); lit 8]
              ; [ff (-2); lit (-7); lit 9]
              ; [lit (-8); lit (-9); ff 10]
              ; [tt (-10); lit 11]
              ; [lit (-11); lit 12]
              ; [tt (-10); ff (-2); lit (-12)]
              ; [tt (-10); ff (-2)]
              ]
            , [dd 1; dd 2; lit (-10)]
            )
          ; (rule ${\Decide [3\text!{-}4]}
            , [ [ff (-1); ff (-2); ff (-3); ff (-4); lit 5]
              ; [ff (-3); ff (-4); lit (-6)]
              ; [lit (-5); lit 6; ff (-1); lit 7]
              ; [lit (-7); lit 8]
              ; [ff (-2); lit (-7); lit 9]
              ; [lit (-8); lit (-9); ff 10]
              ; [tt (-10); lit 11]
              ; [lit (-11); lit 12]
              ; [tt (-10); ff (-2); lit (-12)]
              ; [tt (-10); ff (-2)]
              ]
            , [lit (-10); somit; dd 4]
            )
          ; (rule ${\UnitProp[5\text!{-}8]}
            , [ [ff (-1); ff (-2); ff (-3); ff (-4); tt 5]
              ; [ff (-3); ff (-4); tt (-6)]
              ; [ff (-5); ff 6; ff (-1); tt 7]
              ; [ff (-7); tt 8]
              ; [ff (-2); ff (-7); xx 9]
              ; [ff (-8); xx (-9); ff 10]
              ; [tt (-10); lit 11]
              ; [lit (-11); lit 12]
              ; [tt (-10); ff (-2); lit (-12)]
              ; [tt (-10); ff (-2)]
              ]
            , [lit (-10); somit; lit 8]
            )
          ; (bj
            , [ [ff (-1); ff (-2); lit (-3); lit (-4); lit 5]
              ; [lit (-3); lit (-4); lit (-6)]
              ; [lit (-5); lit 6; ff (-1); lit 7]
              ; [lit (-7); lit 8]
              ; [ff (-2); lit (-7); lit 9]
              ; [lit (-8); lit (-9); ff 10]
              ; [tt (-10); lit 11]
              ; [lit (-11); lit 12]
              ; [tt (-10); ff (-2); lit (-12)]
              ; [tt (-10); ff (-2)]
              ; [ff (-2); lit (-7); ff 10]
              ]
            , [dd 1; dd 2; lit (-10)]
            )
          ; (unit-prop (-7)
            , [ [ff (-1); ff (-2); lit (-3); lit (-4); lit 5]
              ; [lit (-3); lit (-4); lit (-6)]
              ; [lit (-5); lit 6; ff (-1); ff 7]
              ; [tt (-7); lit 8]
              ; [ff (-2); tt (-7); lit 9]
              ; [lit (-8); lit (-9); ff 10]
              ; [tt (-10); lit 11]
              ; [lit (-11); lit 12]
              ; [tt (-10); ff (-2); lit (-12)]
              ; [tt (-10); ff (-2)]
              ; [ff (-2); tt (-7); ff 10]
              ]
            , [somit; lit (-7)]
            )
          ; (rule ${\Decide[3\text!{-}4]}
            , [ [ff (-1); ff (-2); ff (-3); ff (-4); lit 5]
              ; [ff (-3); ff (-4); lit (-6)]
              ; [lit (-5); lit 6; ff (-1); ff 7]
              ; [tt (-7); lit 8]
              ; [ff (-2); tt (-7); lit 9]
              ; [lit (-8); lit (-9); ff 10]
              ; [tt (-10); lit 11]
              ; [lit (-11); lit 12]
              ; [tt (-10); ff (-2); lit (-12)]
              ; [tt (-10); ff (-2)]
              ; [ff (-2); tt (-7); ff 10]
              ]
            , [somit; dd 4]
            )
          ; (rule ${\UnitProp[5\text!{-}6]}
            , [ [ff (-1); ff (-2); ff (-3); ff (-4); tt 5]
              ; [ff (-3); ff (-4); tt (-6)]
              ; [ff (-5); ff 6; ff (-1); ff 7]
              ; [tt (-7); lit 8]
              ; [ff (-2); tt (-7); lit 9]
              ; [lit (-8); lit (-9); ff 10]
              ; [tt (-10); lit 11]
              ; [lit (-11); lit 12]
              ; [tt (-10); ff (-2); lit (-12)]
              ; [tt (-10); ff (-2)]
              ; [ff (-2); tt (-7); ff 10]
              ]
            , [somit; lit (-6)]
            )
          ; (dec 8
            , [ [ff (-1); ff (-2); ff (-3); ff (-4); tt 5]
              ; [ff (-3); ff (-4); tt (-6)]
              ; [ff (-5); ff 6; ff (-1); ff 7]
              ; [tt (-7); tt 8]
              ; [ff (-2); tt (-7); lit 9]
              ; [ff (-8); lit (-9); ff 10]
              ; [tt (-10); lit 11]
              ; [lit (-11); lit 12]
              ; [tt (-10); ff (-2); lit (-12)]
              ; [tt (-10); ff (-2)]
              ; [ff (-2); tt (-7); ff 10]
              ]
            , [somit; dd 8]
            )
          ; (unit-prop (-9)
            , [ [ff (-1); ff (-2); ff (-3); ff (-4); tt 5]
              ; [ff (-3); ff (-4); tt (-6)]
              ; [ff (-5); ff 6; ff (-1); ff 7]
              ; [tt (-7); tt 8]
              ; [ff (-2); tt (-7); ff 9]
              ; [ff (-8); tt (-9); ff 10]
              ; [tt (-10); lit 11]
              ; [lit (-11); lit 12]
              ; [tt (-10); ff (-2); lit (-12)]
              ; [tt (-10); ff (-2)]
              ; [ff (-2); tt (-7); ff 10]
              ]
            , [somit; dd 4; somit; lit (-6); dd 8; lit (-9)]
            )
          ; (dec 11
            , [ [ff (-1); ff (-2); ff (-3); ff (-4); tt 5]
              ; [ff (-3); ff (-4); tt (-6)]
              ; [ff (-5); ff 6; ff (-1); ff 7]
              ; [tt (-7); tt 8]
              ; [ff (-2); tt (-7); ff 9]
              ; [ff (-8); tt (-9); ff 10]
              ; [tt (-10); tt 11]
              ; [ff (-11); lit 12]
              ; [tt (-10); ff (-2); lit (-12)]
              ; [tt (-10); ff (-2)]
              ; [ff (-2); tt (-7); ff 10]
              ]
            , [somit;  lit 11]
            )
          ; (unit-prop 12
            , [ [ff (-1); ff (-2); ff (-3); ff (-4); tt 5]
              ; [ff (-3); ff (-4); tt (-6)]
              ; [ff (-5); ff 6; ff (-1); ff 7]
              ; [tt (-7); tt 8]
              ; [ff (-2); tt (-7); ff 9]
              ; [ff (-8); tt (-9); ff 10]
              ; [tt (-10); tt 11]
              ; [ff (-11); tt 12]
              ; [tt (-10); ff (-2); ff (-12)]
              ; [tt (-10); ff (-2)]
              ; [ff (-2); tt (-7); ff 10]
              ]
            , [dd 1; somit;  lit 12]
            )
          ];
      >

      +centering{Backjump 二回だけですんなり解けている！}
    >);


    +frame-nofooter{CDCL：更なる最適化手法}<
      +p{
        現代のCDCLでは以下のようなテクニックで効率化が図られている：
      }
      +listing{
        * \emph{監視リテラル}：単位節または矛盾節の検出方法の効率化
            ** 観察：単位節・矛盾節確定するのは、リテラル数が\emph{2以下}になったときだけ
            ** そこで、節ごとに\emph{最大2つのリテラルを監視リテラル}として指定
            ** 監視リテラルの真偽が確定したときだけ、その節の状態を確かめて単位節・矛盾節の検出を行えばよい！
        * \emph{変数選択ヒューリスティクス}：場合分けする変数と真偽には任意性がある
            ** どのリテラル、値を選ぶかで\emph{性能が大きく変わる}
            ** 時間減衰する優先度をつかう\emph{VSIDS} など変数選択の指標が提案されている
            ** 選択の指標に関しては、例えば Liangらの論文\cite[`Liang:2015`]; が詳しい
      }
    >

    +frame{CDCL：更なる最適化手法（続）}<
      +listing{
        * \emph{リスタート}：履歴の破棄
            ** 辿った履歴によって簡単にとけたり、逆に永遠に解けなかったりする
            ** そこで矛盾が起きたら一定間隔で状態を破棄し、\emph{ゼロから解きなおす}
            ** 学習節は捨てず、間隔はだんだん長くするので、完全性は担保される
            ** リスタート間隔のヒューリスティクスは Wu らの論文\cite[`Wu:2006`]; が詳しい
        * \emph{忘却}：増えすぎた節の枝刈りをする
            ** 矛盾のたびに学習節が増えるので、節数が爆発しがち
            ** そこで、適切な指標の下で優先度の低い学習節を定期的に削除
            ** 削除するのは学習節だけなので、完全性に影響しない
      }
    >
  >

  +section{|まとめ|}<
    +namedframe(`まとめ`){\select(from 2){Any Questions?}{まとめ}}<
      +listing{
        * Matome here
      }
    >
    +frame-nofooter{参考文献}<
      +font-style[font-size bib-size]<
        +makebibliography 
          ?:(|sort-references=true; 
              citestyle=CiteAsNumber;
              name-shrink=true;
            |)
          (bibyfi-theme)(bibs);
      >
    >
  >
>